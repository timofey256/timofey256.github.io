<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="4.4.1">Jekyll</generator><link href="https://timofey256.github.io/feed.xml" rel="self" type="application/atom+xml"/><link href="https://timofey256.github.io/" rel="alternate" type="text/html" hreflang="en"/><updated>2025-07-19T23:00:00+00:00</updated><id>https://timofey256.github.io/feed.xml</id><title type="html">Tymofii’s blog</title><subtitle>A simple, whitespace theme for academics. Based on [*folio](https://github.com/bogoli/-folio) design. </subtitle><entry><title type="html">an overview of C# multithreading</title><link href="https://timofey256.github.io/blog/2025/multithreading-in-csharp/" rel="alternate" type="text/html" title="an overview of C# multithreading"/><published>2025-07-15T00:00:00+00:00</published><updated>2025-07-15T00:00:00+00:00</updated><id>https://timofey256.github.io/blog/2025/multithreading-in-csharp</id><content type="html" xml:base="https://timofey256.github.io/blog/2025/multithreading-in-csharp/"><![CDATA[<p>I’ve recently taken some time to refresh my understanding of multithreading in C#. This post is a collection of notes I wrote down along the way. It’s not a tutorial - more of a compact reference I (and you) can return to when there’s a need to recall how things work.</p> <p>It covers core concepts like threads, tasks, synchronization primitives, data parallelism, async streams, and more. I’ve included practical examples and benchmarks where they make sense, but the goal isn’t to teach everything from scratch—just to gather the important patterns, behaviors, and gotchas in one place.</p> <hr/> <h2 id="threads">Threads</h2> <div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">void</span> <span class="nf">MethodName</span><span class="p">()</span> <span class="p">{</span> <span class="cm">/* do smth */</span> <span class="p">}</span>

<span class="n">Thread</span> <span class="n">t1</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">Thread</span><span class="p">(</span><span class="n">MethodName</span><span class="p">);</span>
<span class="n">t1</span><span class="p">.</span><span class="nf">Start</span><span class="p">();</span>
<span class="n">t1</span><span class="p">.</span><span class="nf">Join</span><span class="p">();</span>
<span class="n">t1</span><span class="p">.</span><span class="nf">Interrupt</span><span class="p">();</span>                 <span class="c1">// abort if blocked</span>
<span class="n">t1</span><span class="p">.</span><span class="n">IsBackground</span> <span class="p">=</span> <span class="k">true</span><span class="p">;</span>
<span class="n">t1</span><span class="p">.</span><span class="n">Priority</span> <span class="p">=</span> <span class="n">ThreadPriority</span><span class="p">.</span><span class="n">Highest</span><span class="p">;</span>

<span class="kt">int</span> <span class="n">id</span> <span class="p">=</span> <span class="n">Thread</span><span class="p">.</span><span class="n">CurrentThread</span><span class="p">.</span><span class="n">ManagedThreadId</span><span class="p">;</span>
</code></pre></div></div> <p><em>Default stack size of a .NET thread is 1 MiB</em>. You can change it by passing <code class="language-plaintext highlighter-rouge">stackSize</code> in the ctor:</p> <div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">var</span> <span class="n">t</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">Thread</span><span class="p">(</span><span class="n">SomeMethod</span><span class="p">,</span> <span class="n">stackSize</span><span class="p">:</span> <span class="m">512</span> <span class="p">*</span> <span class="m">1024</span><span class="p">);</span>
</code></pre></div></div> <hr/> <h2 id="tasks-await-and-concurrency">Tasks, Await, and Concurrency</h2> <p>Tasks represent units of work, while Threads are C# abstractions over OS Threads.</p> <h4 id="threadsvstasks">Threads vs Tasks</h4> <table> <thead> <tr> <th> </th> <th><code class="language-plaintext highlighter-rouge">Thread</code></th> <th><code class="language-plaintext highlighter-rouge">Task</code></th> </tr> </thead> <tbody> <tr> <td>Represents</td> <td>running OS thread</td> <td>unit of work</td> </tr> <tr> <td>Create with</td> <td><code class="language-plaintext highlighter-rouge">new Thread</code></td> <td><code class="language-plaintext highlighter-rouge">Task.Run</code> (ThreadPool)</td> </tr> <tr> <td>Use for</td> <td>long‑lived, STA, custom stack</td> <td>bursty CPU or async I/O</td> </tr> </tbody> </table> <h4 id="configureawait">ConfigureAwait</h4> <p>How await works by default</p> <ul> <li>The compiler inserts an awaiter for every await task;.</li> <li>Just before suspension it captures the current <ul> <li>SynchronizationContext (if one exists, e.g., WinForms/WPF UI thread, classic ASP.NET request thread) or</li> <li>the current TaskScheduler (usually the ThreadPool).</li> </ul> </li> <li>When task completes, the continuation is posted back to that captured context so your method keeps executing on the original thread.</li> </ul> <p><code class="language-plaintext highlighter-rouge">ConfigureAwait(bool)</code> lets you to set if you want this capture to happen or not. So we can roughly make the following distinction:</p> <div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>UI apps (WinForms/WPF)    : ConfigureAwait(true)
Libraries / ASP.NET Core  : ConfigureAwait(false)
</code></pre></div></div> <h4 id="task-continuations">Task continuations</h4> <p>A continuation is code that runs after a <code class="language-plaintext highlighter-rouge">Task</code> completes, without blocking the current thread. You define it using the <code class="language-plaintext highlighter-rouge">ContinueWith</code> method:</p> <div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Task</span> <span class="n">first</span> <span class="p">=</span> <span class="nf">SomeTask</span><span class="p">();</span>
<span class="n">first</span><span class="p">.</span><span class="nf">ContinueWith</span><span class="p">(</span><span class="n">t</span> <span class="p">=&gt;</span> <span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span><span class="s">"This runs after SomeTask completes."</span><span class="p">));</span>
</code></pre></div></div> <p>This creates a dependency chain between tasks.</p> <h4 id="be-careful-with-chained-task-continuations">Be careful with chained task continuations</h4> <p>Can you spot a problem here? What the below code will print? Is it expected?</p> <div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">static</span> <span class="n">Task</span> <span class="nf">DoFirstThing</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">Task</span><span class="p">.</span><span class="nf">Run</span><span class="p">(()</span> <span class="p">=&gt;</span> <span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span><span class="s">"First thing done"</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">Task</span> <span class="nf">DoSecondThing</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">Task</span><span class="p">.</span><span class="nf">Delay</span><span class="p">(</span><span class="m">1000</span><span class="p">).</span><span class="nf">ContinueWith</span><span class="p">(</span><span class="n">_</span> <span class="p">=&gt;</span> <span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span><span class="s">"Second thing done"</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">Task</span> <span class="nf">DoThirdThing</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">Task</span><span class="p">.</span><span class="nf">Run</span><span class="p">(()</span> <span class="p">=&gt;</span> <span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span><span class="s">"Third thing done"</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">void</span> <span class="nf">Main</span><span class="p">(</span><span class="kt">string</span><span class="p">[]</span> <span class="n">args</span><span class="p">)</span>
<span class="p">{</span>
    <span class="nf">DoFirstThing</span><span class="p">().</span><span class="nf">ContinueWith</span><span class="p">(</span><span class="n">_</span> <span class="p">=&gt;</span> <span class="nf">DoSecondThing</span><span class="p">()).</span><span class="nf">ContinueWith</span><span class="p">(</span><span class="n">_</span> <span class="p">=&gt;</span> <span class="nf">DoThirdThing</span><span class="p">());</span>

    <span class="n">Console</span><span class="p">.</span><span class="nf">ReadLine</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div></div> <details><summary>Open see the answer</summary> <p>Program output:</p> <div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>First thing done.
Third thing done.
Second thing done.
</code></pre></div></div> <p>Order is wrong because of the incorrect usage of continuations. In <code class="language-plaintext highlighter-rouge">DoSecondThing()</code> we return a <code class="language-plaintext highlighter-rouge">Task&lt;Task&gt;</code>, because <code class="language-plaintext highlighter-rouge">ContinueWith</code> always returns <code class="language-plaintext highlighter-rouge">Task&lt;T&gt;</code> where <code class="language-plaintext highlighter-rouge">T</code> is the return type of the delegate which is Task in this case. The next <code class="language-plaintext highlighter-rouge">ContinueWith</code> will just unwrap the first <code class="language-plaintext highlighter-rouge">Task</code>, getting <code class="language-plaintext highlighter-rouge">Task</code>, so will not await anything.</p> <p>The correct usage would be:</p> <div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">DoFirstThing</span><span class="p">().</span><span class="nf">ContinueWith</span><span class="p">(</span><span class="n">_</span> <span class="p">=&gt;</span> <span class="nf">DoSecondThing</span><span class="p">()).</span><span class="nf">Unwrap</span><span class="p">().</span><span class="nf">ContinueWith</span><span class="p">(</span><span class="n">_</span> <span class="p">=&gt;</span> <span class="nf">DoThirdThing</span><span class="p">());</span>
</code></pre></div></div> <p>Alternatively, you could use 3 <code class="language-plaintext highlighter-rouge">await</code> lines, or nested continuations.</p> </details> <h4 id="timeout--cancellation">Timeout / cancellation</h4> <p>You can add timeouts to awaits:</p> <div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">await</span> <span class="nf">DoWorkAsync</span><span class="p">().</span><span class="nf">WaitAsync</span><span class="p">(</span><span class="n">TimeSpan</span><span class="p">.</span><span class="nf">FromSeconds</span><span class="p">(</span><span class="m">2</span><span class="p">));</span>
</code></pre></div></div> <h4 id="taskrunvstaskfactorystartnew"><code class="language-plaintext highlighter-rouge">Task.Run</code> vs <code class="language-plaintext highlighter-rouge">Task.Factory.StartNew</code></h4> <p><code class="language-plaintext highlighter-rouge">Task.Run(f)</code> ≈ <code class="language-plaintext highlighter-rouge">Task.Factory.StartNew(f, TaskCreationOptions.DenyChildAttach).Unwrap()</code>.</p> <hr/> <h2 id="data-parallelism">Data Parallelism</h2> <p>Data parallelism refers to scenarios in which the same operation is performed concurrently (that is, in parallel) on elements in a source collection or array. In data parallel operations, the source collection is partitioned so that multiple threads can operate on different segments concurrently.</p> <p>Let’s try to implement some data parallelism using raw tasks - we will have an array <code class="language-plaintext highlighter-rouge">bitmaps</code> and we want to apply <code class="language-plaintext highlighter-rouge">ApplyFilter</code> on each of its elements.</p> <div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">degree</span> <span class="p">=</span> <span class="n">Environment</span><span class="p">.</span><span class="n">ProcessorCount</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">chunk</span>  <span class="p">=</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">Math</span><span class="p">.</span><span class="nf">Ceiling</span><span class="p">(</span><span class="n">bitmaps</span><span class="p">.</span><span class="n">Length</span> <span class="p">/</span> <span class="p">(</span><span class="kt">double</span><span class="p">)</span><span class="n">degree</span><span class="p">);</span>

<span class="kt">var</span> <span class="n">tasks</span> <span class="p">=</span> <span class="n">Enumerable</span><span class="p">.</span><span class="nf">Range</span><span class="p">(</span><span class="m">0</span><span class="p">,</span> <span class="n">degree</span><span class="p">).</span><span class="nf">Select</span><span class="p">(</span><span class="n">core</span> <span class="p">=&gt;</span> <span class="n">Task</span><span class="p">.</span><span class="nf">Run</span><span class="p">(()</span> <span class="p">=&gt;</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">start</span> <span class="p">=</span> <span class="n">core</span> <span class="p">*</span> <span class="n">chunk</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">end</span>   <span class="p">=</span> <span class="n">Math</span><span class="p">.</span><span class="nf">Min</span><span class="p">(</span><span class="n">start</span> <span class="p">+</span> <span class="n">chunk</span><span class="p">,</span> <span class="n">bitmaps</span><span class="p">.</span><span class="n">Length</span><span class="p">);</span>

    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="p">=</span> <span class="n">start</span><span class="p">;</span> <span class="n">i</span> <span class="p">&lt;</span> <span class="n">end</span><span class="p">;</span> <span class="n">i</span><span class="p">++)</span>
        <span class="n">bitmaps</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="p">=</span> <span class="nf">ApplyFilter</span><span class="p">(</span><span class="n">bitmaps</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
<span class="p">})).</span><span class="nf">ToArray</span><span class="p">();</span>

<span class="k">await</span> <span class="n">Task</span><span class="p">.</span><span class="nf">WhenAll</span><span class="p">(</span><span class="n">tasks</span><span class="p">);</span>
</code></pre></div></div> <p>As you see, we had to deal with a lot of low-level things - specifying chunk sizes, manually calculating indices, etc. It’s easy to make bugs when writing code like this.</p> <p>Fortunately, .NET Task Parallel Library (TPL) has <code class="language-plaintext highlighter-rouge">System.Threading.Tasks.Parallel</code> class. Using it we can rewrite the above code piece much more concisely:</p> <div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Parallel</span><span class="p">.</span><span class="nf">For</span><span class="p">(</span><span class="m">0</span><span class="p">,</span> <span class="n">bitmaps</span><span class="p">.</span><span class="n">Length</span><span class="p">,</span> <span class="n">i</span> <span class="p">=&gt;</span>
<span class="p">{</span>
    <span class="n">bitmaps</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="p">=</span> <span class="nf">ApplyFilter</span><span class="p">(</span><span class="n">bitmaps</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
<span class="p">});</span>
</code></pre></div></div> <h4 id="parallel-also-supports-async"><code class="language-plaintext highlighter-rouge">Parallel</code> also supports Async</h4> <p>Fetching a resource w/o <code class="language-plaintext highlighter-rouge">Parallel</code>:</p> <div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">using</span> <span class="nn">var</span> <span class="n">sem</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">SemaphoreSlim</span><span class="p">(</span><span class="m">2</span><span class="p">);</span>
<span class="kt">var</span> <span class="n">tasks</span> <span class="p">=</span> <span class="n">urls</span><span class="p">.</span><span class="nf">Select</span><span class="p">(</span><span class="k">async</span> <span class="n">url</span> <span class="p">=&gt;</span>
<span class="p">{</span>
    <span class="k">await</span> <span class="n">sem</span><span class="p">.</span><span class="nf">WaitAsync</span><span class="p">();</span>
    <span class="k">try</span>   <span class="p">{</span> <span class="k">await</span> <span class="nf">FetchAsync</span><span class="p">(</span><span class="n">url</span><span class="p">,</span> <span class="n">CancellationToken</span><span class="p">.</span><span class="n">None</span><span class="p">);</span> <span class="p">}</span>
    <span class="k">finally</span> <span class="p">{</span> <span class="n">sem</span><span class="p">.</span><span class="nf">Release</span><span class="p">();</span> <span class="p">}</span>
<span class="p">});</span>
<span class="k">await</span> <span class="n">Task</span><span class="p">.</span><span class="nf">WhenAll</span><span class="p">(</span><span class="n">tasks</span><span class="p">);</span>
</code></pre></div></div> <p>With <code class="language-plaintext highlighter-rouge">Parallel</code>:</p> <div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">await</span> <span class="n">Parallel</span><span class="p">.</span><span class="nf">ForEachAsync</span><span class="p">(</span><span class="n">urls</span><span class="p">,</span>
    <span class="k">new</span> <span class="n">ParallelOptions</span> <span class="p">{</span> <span class="n">MaxDegreeOfParallelism</span> <span class="p">=</span> <span class="m">2</span> <span class="p">},</span>
    <span class="k">async</span> <span class="p">(</span><span class="n">url</span><span class="p">,</span> <span class="n">ct</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="k">await</span> <span class="nf">FetchAsync</span><span class="p">(</span><span class="n">url</span><span class="p">,</span> <span class="n">ct</span><span class="p">));</span>
</code></pre></div></div> <h4 id="parallelforeachasync-vs-taskwhenall"><code class="language-plaintext highlighter-rouge">Parallel.ForEachAsync</code> vs <code class="language-plaintext highlighter-rouge">Task.WhenAll</code></h4> <p>You can see above a useful feature of <code class="language-plaintext highlighter-rouge">Parallel.ForEachAsync</code>: it let’s you specify degree of your parallelism.</p> <hr/> <h2 id="atomicity-visibility-and-locks">Atomicity, Visibility, and Locks</h2> <h4 id="volatile">volatile</h4> <p>Guarantees reads/writes hit main memory and adds fences that stop CPU/compiler re‑ordering.</p> <h4 id="systemthreadinginterlocked"><code class="language-plaintext highlighter-rouge">System.Threading.Interlocked</code></h4> <div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">counter</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span>
<span class="n">Interlocked</span><span class="p">.</span><span class="nf">Increment</span>  <span class="p">(</span><span class="k">ref</span> <span class="n">counter</span><span class="p">);</span>
<span class="n">Interlocked</span><span class="p">.</span><span class="nf">Decrement</span>  <span class="p">(</span><span class="k">ref</span> <span class="n">counter</span><span class="p">);</span>
<span class="n">Interlocked</span><span class="p">.</span><span class="nf">Add</span>        <span class="p">(</span><span class="k">ref</span> <span class="n">counter</span><span class="p">,</span> <span class="m">5</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">old</span> <span class="p">=</span> <span class="n">Interlocked</span><span class="p">.</span><span class="nf">Exchange</span><span class="p">(</span><span class="k">ref</span> <span class="n">counter</span><span class="p">,</span> <span class="m">100</span><span class="p">);</span>
<span class="n">Interlocked</span><span class="p">.</span><span class="nf">CompareExchange</span><span class="p">(</span><span class="k">ref</span> <span class="n">counter</span><span class="p">,</span> <span class="m">10</span><span class="p">,</span> <span class="m">5</span><span class="p">);</span> <span class="c1">// set to 10 only when counter == 5</span>
</code></pre></div></div> <h4 id="interlockedvslockbenchmark">Interlocked vs lock (benchmark)</h4> <p>Why should you use <code class="language-plaintext highlighter-rouge">Interlocked</code> instead of <code class="language-plaintext highlighter-rouge">lock</code> whenever you can? Let’s compare their performance.</p> <details><summary>Open to see the benchmark code</summary> <div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">CompareInterlockedAndLockProgram</span>
<span class="p">{</span>
    <span class="k">static</span> <span class="kt">int</span> <span class="n">N</span> <span class="p">=</span> <span class="m">1_000_000</span><span class="p">;</span> <span class="c1">// Increments per thread</span>
    <span class="k">static</span> <span class="kt">int</span> <span class="n">T</span> <span class="p">=</span> <span class="m">4</span><span class="p">;</span>         <span class="c1">// Number of threads</span>

    <span class="k">static</span> <span class="k">void</span> <span class="nf">RunWithInterlocked</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="kt">int</span> <span class="n">counter</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span>

        <span class="k">void</span> <span class="nf">Work</span><span class="p">()</span>
        <span class="p">{</span>
            <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="p">&lt;</span> <span class="n">N</span><span class="p">;</span> <span class="n">i</span><span class="p">++)</span>
                <span class="n">Interlocked</span><span class="p">.</span><span class="nf">Increment</span><span class="p">(</span><span class="k">ref</span> <span class="n">counter</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="n">Thread</span><span class="p">[]</span> <span class="n">threads</span> <span class="p">=</span> <span class="k">new</span> <span class="n">Thread</span><span class="p">[</span><span class="n">T</span><span class="p">];</span>
        <span class="n">Stopwatch</span> <span class="n">sw</span> <span class="p">=</span> <span class="n">Stopwatch</span><span class="p">.</span><span class="nf">StartNew</span><span class="p">();</span>

        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="p">&lt;</span> <span class="n">T</span><span class="p">;</span> <span class="n">i</span><span class="p">++)</span> <span class="n">threads</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">Thread</span><span class="p">(</span><span class="n">Work</span><span class="p">);</span>
        <span class="k">foreach</span> <span class="p">(</span><span class="kt">var</span> <span class="n">t</span> <span class="k">in</span> <span class="n">threads</span><span class="p">)</span> <span class="n">t</span><span class="p">.</span><span class="nf">Start</span><span class="p">();</span>
        <span class="k">foreach</span> <span class="p">(</span><span class="kt">var</span> <span class="n">t</span> <span class="k">in</span> <span class="n">threads</span><span class="p">)</span> <span class="n">t</span><span class="p">.</span><span class="nf">Join</span><span class="p">();</span>

        <span class="n">sw</span><span class="p">.</span><span class="nf">Stop</span><span class="p">();</span>
        <span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span><span class="s">$"Interlocked: </span><span class="p">{</span><span class="n">sw</span><span class="p">.</span><span class="n">ElapsedMilliseconds</span><span class="p">}</span><span class="s"> ms | Final = </span><span class="p">{</span><span class="n">counter</span><span class="p">}</span><span class="s">"</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">static</span> <span class="k">void</span> <span class="nf">RunWithLock</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="kt">int</span> <span class="n">counter</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span>
        <span class="kt">object</span> <span class="n">lockObj</span> <span class="p">=</span> <span class="k">new</span> <span class="kt">object</span><span class="p">();</span>

        <span class="k">void</span> <span class="nf">Work</span><span class="p">()</span>
        <span class="p">{</span>
            <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="p">&lt;</span> <span class="n">N</span><span class="p">;</span> <span class="n">i</span><span class="p">++)</span>
            <span class="p">{</span>
                <span class="k">lock</span> <span class="p">(</span><span class="n">lockObj</span><span class="p">)</span>
                <span class="p">{</span>
                    <span class="n">counter</span><span class="p">++;</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="n">Thread</span><span class="p">[]</span> <span class="n">threads</span> <span class="p">=</span> <span class="k">new</span> <span class="n">Thread</span><span class="p">[</span><span class="n">T</span><span class="p">];</span>
        <span class="n">Stopwatch</span> <span class="n">sw</span> <span class="p">=</span> <span class="n">Stopwatch</span><span class="p">.</span><span class="nf">StartNew</span><span class="p">();</span>

        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="p">&lt;</span> <span class="n">T</span><span class="p">;</span> <span class="n">i</span><span class="p">++)</span> <span class="n">threads</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">Thread</span><span class="p">(</span><span class="n">Work</span><span class="p">);</span>
        <span class="k">foreach</span> <span class="p">(</span><span class="kt">var</span> <span class="n">t</span> <span class="k">in</span> <span class="n">threads</span><span class="p">)</span> <span class="n">t</span><span class="p">.</span><span class="nf">Start</span><span class="p">();</span>
        <span class="k">foreach</span> <span class="p">(</span><span class="kt">var</span> <span class="n">t</span> <span class="k">in</span> <span class="n">threads</span><span class="p">)</span> <span class="n">t</span><span class="p">.</span><span class="nf">Join</span><span class="p">();</span>

        <span class="n">sw</span><span class="p">.</span><span class="nf">Stop</span><span class="p">();</span>
        <span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span><span class="s">$"Lock:       </span><span class="p">{</span><span class="n">sw</span><span class="p">.</span><span class="n">ElapsedMilliseconds</span><span class="p">}</span><span class="s"> ms | Final = </span><span class="p">{</span><span class="n">counter</span><span class="p">}</span><span class="s">"</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">public</span> <span class="k">static</span> <span class="k">void</span> <span class="nf">Start</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="nf">RunWithInterlocked</span><span class="p">();</span>
        <span class="nf">RunWithLock</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">class</span> <span class="nc">Program</span> <span class="p">{</span>
    <span class="k">public</span> <span class="k">static</span> <span class="k">void</span> <span class="nf">Main</span><span class="p">(</span><span class="kt">string</span><span class="p">[]</span> <span class="n">args</span><span class="p">)</span> <span class="p">{</span>
       <span class="n">CompareInterlockedAndLockProgram</span><span class="p">.</span><span class="nf">Start</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div> </details> <p>Typical run on 4 threads × 1 M increments each:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Interlocked: 42 ms | Final = 4000000
Lock:       101 ms | Final = 4000000
</code></pre></div></div> <hr/> <h2 id="basic-synchronization-primitives">Basic Synchronization Primitives</h2> <h3 id="semaphoreslim">SemaphoreSlim</h3> <p>Control how many concurrent callers enter a critical section. <code class="language-plaintext highlighter-rouge">SemaphoreSlim</code> is also async‑friendly. Limit a CPU‑bound method to 2 parallel executions.</p> <div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">SemaphoreSlim</span> <span class="n">sem</span> <span class="p">=</span> <span class="k">new</span><span class="p">(</span><span class="m">2</span><span class="p">,</span> <span class="m">2</span><span class="p">);</span>

<span class="k">async</span> <span class="n">Task</span> <span class="nf">WorkAsync</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">await</span> <span class="n">sem</span><span class="p">.</span><span class="nf">WaitAsync</span><span class="p">();</span>           <span class="c1">// ↓ counter or wait</span>
    <span class="k">try</span>   <span class="p">{</span> <span class="k">await</span> <span class="nf">DoHeavyStuff</span><span class="p">();</span> <span class="p">}</span>
    <span class="k">finally</span> <span class="p">{</span> <span class="n">sem</span><span class="p">.</span><span class="nf">Release</span><span class="p">();</span> <span class="p">}</span>       <span class="c1">// ↑ counter</span>
<span class="p">}</span>
</code></pre></div></div> <hr/> <h4 id="manualreseteventslim">ManualResetEventSlim</h4> <p>One thread signals many waiters; stays signalled until reset. Let all tasks start only after a warm‑up step.</p> <div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">var</span> <span class="n">go</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">ManualResetEventSlim</span><span class="p">(</span><span class="k">false</span><span class="p">);</span>

<span class="n">Task</span><span class="p">.</span><span class="nf">Run</span><span class="p">(()</span> <span class="p">=&gt;</span> <span class="p">{</span> <span class="nf">WarmUp</span><span class="p">();</span> <span class="n">go</span><span class="p">.</span><span class="nf">Set</span><span class="p">();</span> <span class="p">});</span>        <span class="c1">// signal ON</span>

<span class="n">Parallel</span><span class="p">.</span><span class="nf">For</span><span class="p">(</span><span class="m">0</span><span class="p">,</span> <span class="m">8</span><span class="p">,</span> <span class="n">i</span> <span class="p">=&gt;</span>
<span class="p">{</span>
    <span class="n">go</span><span class="p">.</span><span class="nf">Wait</span><span class="p">();</span>                                  <span class="c1">// all block here</span>
    <span class="nf">Process</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
<span class="p">});</span>
</code></pre></div></div> <hr/> <h4 id="autoreseteventslim">AutoResetEventSlim</h4> <p>Signal wakes <strong>one</strong> waiter, then auto‑resets. Classic producer–consumer hand‑shake.</p> <div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">var</span> <span class="n">evt</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">AutoResetEventSlim</span><span class="p">(</span><span class="k">false</span><span class="p">);</span>

<span class="n">Task</span><span class="p">.</span><span class="nf">Run</span><span class="p">(()</span> <span class="p">=&gt;</span>                        <span class="c1">// producer</span>
<span class="p">{</span>
    <span class="k">while</span> <span class="p">(</span><span class="nf">Produce</span><span class="p">(</span><span class="k">out</span> <span class="kt">var</span> <span class="n">item</span><span class="p">))</span>
    <span class="p">{</span>
        <span class="n">queue</span><span class="p">.</span><span class="nf">Enqueue</span><span class="p">(</span><span class="n">item</span><span class="p">);</span>
        <span class="n">evt</span><span class="p">.</span><span class="nf">Set</span><span class="p">();</span>                    <span class="c1">// wake one consumer</span>
    <span class="p">}</span>
<span class="p">});</span>

<span class="n">Task</span><span class="p">.</span><span class="nf">Run</span><span class="p">(()</span> <span class="p">=&gt;</span>                        <span class="c1">// consumer</span>
<span class="p">{</span>
    <span class="k">while</span> <span class="p">(</span><span class="k">true</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">evt</span><span class="p">.</span><span class="nf">Wait</span><span class="p">();</span>                   <span class="c1">// waits again after each Set()</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">queue</span><span class="p">.</span><span class="nf">TryDequeue</span><span class="p">(</span><span class="k">out</span> <span class="kt">var</span> <span class="n">x</span><span class="p">))</span> <span class="nf">Use</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">});</span>
</code></pre></div></div> <hr/> <h4 id="countdownevent">CountdownEvent</h4> <p><strong>Fork / join</strong>: continue when <em>n</em> signals have arrived. Fire off N raw threads, wait for all to finish.</p> <div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">N</span> <span class="p">=</span> <span class="m">3</span><span class="p">;</span>
<span class="kt">var</span> <span class="n">cd</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">CountdownEvent</span><span class="p">(</span><span class="n">N</span><span class="p">);</span>

<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="p">&lt;</span> <span class="n">N</span><span class="p">;</span> <span class="n">i</span><span class="p">++)</span>
    <span class="k">new</span> <span class="nf">Thread</span><span class="p">(()</span> <span class="p">=&gt;</span> <span class="p">{</span> <span class="nf">Work</span><span class="p">();</span> <span class="n">cd</span><span class="p">.</span><span class="nf">Signal</span><span class="p">();</span> <span class="p">}).</span><span class="nf">Start</span><span class="p">();</span>

<span class="n">cd</span><span class="p">.</span><span class="nf">Wait</span><span class="p">();</span>                            <span class="c1">// resumes when Signal() called N times</span>
</code></pre></div></div> <hr/> <h4 id="barrier">Barrier</h4> <p>Multi‑phase workflow: every participant must reach the barrier before any enters the next phase. 4 workers perform Stage 1 → Stage 2 → Stage 3 in lock‑step.</p> <div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">var</span> <span class="n">barrier</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">Barrier</span><span class="p">(</span><span class="m">4</span><span class="p">,</span> <span class="n">_</span> <span class="p">=&gt;</span> <span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span><span class="s">"Phase done"</span><span class="p">));</span>

<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="p">&lt;</span> <span class="m">4</span><span class="p">;</span> <span class="n">i</span><span class="p">++)</span>
    <span class="n">Task</span><span class="p">.</span><span class="nf">Run</span><span class="p">(()</span> <span class="p">=&gt;</span>
    <span class="p">{</span>
        <span class="nf">Stage1</span><span class="p">();</span> <span class="n">barrier</span><span class="p">.</span><span class="nf">SignalAndWait</span><span class="p">();</span>
        <span class="nf">Stage2</span><span class="p">();</span> <span class="n">barrier</span><span class="p">.</span><span class="nf">SignalAndWait</span><span class="p">();</span>
        <span class="nf">Stage3</span><span class="p">();</span> <span class="n">barrier</span><span class="p">.</span><span class="nf">SignalAndWait</span><span class="p">();</span>
    <span class="p">});</span>
</code></pre></div></div> <hr/> <h2 id="producer-consumer-pattern">Producer-Consumer Pattern</h2> <p>Producer-Consumer decouples data creation from data processing: producers push items into a shared buffer while consumers pull them out. In .NET you can choose a blocking queue (<code class="language-plaintext highlighter-rouge">BlockingCollection&lt;T&gt;</code>) or the modern async‑friendly <code class="language-plaintext highlighter-rouge">Channel&lt;T&gt;</code> (you should use the latter most of the time).</p> <h4 id="blocking-collection-threadblocking">Blocking Collection (thread‑blocking)</h4> <aside><p> We use <code>Thread.Sleep</code> here for demonstration. In real code, consider using <code>await Task.Delay</code> for non-blocking waiting. </p></aside> <div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">var</span> <span class="n">queue</span> <span class="p">=</span> <span class="k">new</span> <span class="n">BlockingCollection</span><span class="p">&lt;</span><span class="kt">int</span><span class="p">&gt;(</span><span class="n">boundedCapacity</span><span class="p">:</span> <span class="m">5</span><span class="p">);</span>

<span class="kt">var</span> <span class="n">producer</span> <span class="p">=</span> <span class="n">Task</span><span class="p">.</span><span class="nf">Run</span><span class="p">(()</span> <span class="p">=&gt;</span> <span class="p">{</span>
<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="p">&lt;</span> <span class="m">10</span><span class="p">;</span> <span class="n">i</span><span class="p">++)</span> <span class="p">{</span>
<span class="n">queue</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="n">i</span><span class="p">);</span> <span class="c1">// Blocks if full</span>
<span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span><span class="s">$"Produced: </span><span class="p">{</span><span class="n">i</span><span class="p">}</span><span class="s">"</span><span class="p">);</span>
<span class="n">Thread</span><span class="p">.</span><span class="nf">Sleep</span><span class="p">(</span><span class="m">100</span><span class="p">);</span>  
 <span class="p">}</span>
<span class="n">queue</span><span class="p">.</span><span class="nf">CompleteAdding</span><span class="p">();</span> <span class="c1">// Signal no more items</span>
<span class="p">});</span>

<span class="c1">// Consumer</span>
<span class="kt">var</span> <span class="n">consumer</span> <span class="p">=</span> <span class="n">Task</span><span class="p">.</span><span class="nf">Run</span><span class="p">(()</span> <span class="p">=&gt;</span> <span class="p">{</span>
<span class="k">foreach</span> <span class="p">(</span><span class="kt">var</span> <span class="n">item</span> <span class="k">in</span> <span class="n">queue</span><span class="p">.</span><span class="nf">GetConsumingEnumerable</span><span class="p">())</span> <span class="p">{</span>
<span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span><span class="s">$"\tConsumed: </span><span class="p">{</span><span class="n">item</span><span class="p">}</span><span class="s">"</span><span class="p">);</span>
<span class="n">Thread</span><span class="p">.</span><span class="nf">Sleep</span><span class="p">(</span><span class="m">150</span><span class="p">);</span>
<span class="p">}</span>
<span class="p">});</span>

</code></pre></div></div> <h4 id="channelt-asyncawait">Channel&lt;T&gt; (async/await)</h4> <div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">var</span> <span class="n">channel</span> <span class="p">=</span> <span class="n">Channel</span><span class="p">.</span><span class="n">CreateUnbounded</span><span class="p">&lt;</span><span class="kt">int</span><span class="p">&gt;();</span>

<span class="kt">var</span> <span class="n">producer</span> <span class="p">=</span> <span class="n">Task</span><span class="p">.</span><span class="nf">Run</span><span class="p">(</span><span class="k">async</span> <span class="p">()</span> <span class="p">=&gt;</span>
<span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="p">&lt;</span> <span class="m">10</span><span class="p">;</span> <span class="n">i</span><span class="p">++)</span>
    <span class="p">{</span>
        <span class="k">await</span> <span class="n">channel</span><span class="p">.</span><span class="n">Writer</span><span class="p">.</span><span class="nf">WriteAsync</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
        <span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span><span class="s">$"Produced: </span><span class="p">{</span><span class="n">i</span><span class="p">}</span><span class="s">"</span><span class="p">);</span>
        <span class="k">await</span> <span class="n">Task</span><span class="p">.</span><span class="nf">Delay</span><span class="p">(</span><span class="m">100</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">channel</span><span class="p">.</span><span class="n">Writer</span><span class="p">.</span><span class="nf">Complete</span><span class="p">();</span> <span class="c1">// signal end</span>
<span class="p">});</span>

<span class="kt">var</span> <span class="n">consumer</span> <span class="p">=</span> <span class="n">Task</span><span class="p">.</span><span class="nf">Run</span><span class="p">(</span><span class="k">async</span> <span class="p">()</span> <span class="p">=&gt;</span>
<span class="p">{</span>
    <span class="k">await</span> <span class="k">foreach</span> <span class="p">(</span><span class="kt">var</span> <span class="n">item</span> <span class="k">in</span> <span class="n">channel</span><span class="p">.</span><span class="n">Reader</span><span class="p">.</span><span class="nf">ReadAllAsync</span><span class="p">())</span>
    <span class="p">{</span>
        <span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span><span class="s">$"\tConsumed: </span><span class="p">{</span><span class="n">item</span><span class="p">}</span><span class="s">"</span><span class="p">);</span>
        <span class="k">await</span> <span class="n">Task</span><span class="p">.</span><span class="nf">Delay</span><span class="p">(</span><span class="m">150</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">});</span>

<span class="k">await</span> <span class="n">Task</span><span class="p">.</span><span class="nf">WhenAll</span><span class="p">(</span><span class="n">producer</span><span class="p">,</span> <span class="n">consumer</span><span class="p">);</span>
</code></pre></div></div> <p>Choose bounded channels for <code class="language-plaintext highlighter-rouge">Wait</code>, <code class="language-plaintext highlighter-rouge">DropOldest</code>, etc. Always call <code class="language-plaintext highlighter-rouge">CompleteAdding()</code> / <code class="language-plaintext highlighter-rouge">Writer.Complete()</code>.</p> <hr/> <h2 id="streaming-datausing-iasyncenumerable">Streaming Data using IAsyncEnumerable</h2> <div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">async</span> <span class="n">IAsyncEnumerable</span><span class="p">&lt;</span><span class="kt">string</span><span class="p">&gt;</span> <span class="nf">ReadLargeFileAsync</span><span class="p">(</span><span class="kt">string</span> <span class="n">path</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">using</span> <span class="nn">var</span> <span class="n">r</span> <span class="p">=</span> <span class="n">File</span><span class="p">.</span><span class="nf">OpenText</span><span class="p">(</span><span class="n">path</span><span class="p">);</span>
    <span class="k">while</span> <span class="p">(!</span><span class="n">r</span><span class="p">.</span><span class="n">EndOfStream</span><span class="p">)</span>
        <span class="k">yield</span> <span class="k">return</span> <span class="k">await</span> <span class="n">r</span><span class="p">.</span><span class="nf">ReadLineAsync</span><span class="p">();</span>
<span class="p">}</span>

<span class="k">await</span> <span class="k">foreach</span> <span class="p">(</span><span class="kt">var</span> <span class="n">line</span> <span class="k">in</span> <span class="nf">ReadLargeFileAsync</span><span class="p">(</span><span class="s">"log.txt"</span><span class="p">))</span>
    <span class="nf">Process</span><span class="p">(</span><span class="n">line</span><span class="p">);</span>
</code></pre></div></div> <hr/> <h2 id="async-compatible-initialization">Async-Compatible Initialization</h2> <p><em>Interface pattern</em></p> <div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">interface</span> <span class="nc">IAsyncInitializable</span> <span class="p">{</span> <span class="n">Task</span> <span class="nf">InitializeAsync</span><span class="p">();</span> <span class="p">}</span>
</code></pre></div></div> <p><em>Factory pattern</em></p> <div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">var</span> <span class="n">svc</span> <span class="p">=</span> <span class="k">await</span> <span class="n">MyService</span><span class="p">.</span><span class="nf">CreateAsync</span><span class="p">();</span>
</code></pre></div></div>]]></content><author><name></name></author><category term="programming"/><category term="csharp"/><summary type="html"><![CDATA[notes i've taken while refreshing my knowledge]]></summary></entry></feed>